module.exports = "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// <define:process>\nvar define_process_default;\nvar init_define_process = __esm({\n  \"<define:process>\"() {\n    define_process_default = { env: {}, versions: { node: \"16.6.0\" } };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/symbols.js\nvar require_symbols = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/symbols.js\"(exports2, module2) {\n    \"use strict\";\n    init_define_process();\n    module2.exports = {\n      kUrl: Symbol(\"url\"),\n      kHeaders: Symbol(\"headers\"),\n      kSignal: Symbol(\"signal\"),\n      kState: Symbol(\"state\"),\n      kGuard: Symbol(\"guard\"),\n      kRealm: Symbol(\"realm\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/symbols.js\nvar require_symbols2 = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/symbols.js\"(exports2, module2) {\n    \"use strict\";\n    init_define_process();\n    module2.exports = {\n      kClose: Symbol(\"close\"),\n      kDestroy: Symbol(\"destroy\"),\n      kDispatch: Symbol(\"dispatch\"),\n      kUrl: Symbol(\"url\"),\n      kWriting: Symbol(\"writing\"),\n      kResuming: Symbol(\"resuming\"),\n      kQueue: Symbol(\"queue\"),\n      kConnect: Symbol(\"connect\"),\n      kConnecting: Symbol(\"connecting\"),\n      kHeadersList: Symbol(\"headers list\"),\n      kKeepAliveDefaultTimeout: Symbol(\"default keep alive timeout\"),\n      kKeepAliveMaxTimeout: Symbol(\"max keep alive timeout\"),\n      kKeepAliveTimeoutThreshold: Symbol(\"keep alive timeout threshold\"),\n      kKeepAliveTimeoutValue: Symbol(\"keep alive timeout\"),\n      kKeepAlive: Symbol(\"keep alive\"),\n      kHeadersTimeout: Symbol(\"headers timeout\"),\n      kBodyTimeout: Symbol(\"body timeout\"),\n      kServerName: Symbol(\"server name\"),\n      kLocalAddress: Symbol(\"local address\"),\n      kHost: Symbol(\"host\"),\n      kNoRef: Symbol(\"no ref\"),\n      kBodyUsed: Symbol(\"used\"),\n      kRunning: Symbol(\"running\"),\n      kBlocking: Symbol(\"blocking\"),\n      kPending: Symbol(\"pending\"),\n      kSize: Symbol(\"size\"),\n      kBusy: Symbol(\"busy\"),\n      kQueued: Symbol(\"queued\"),\n      kFree: Symbol(\"free\"),\n      kConnected: Symbol(\"connected\"),\n      kClosed: Symbol(\"closed\"),\n      kNeedDrain: Symbol(\"need drain\"),\n      kReset: Symbol(\"reset\"),\n      kDestroyed: Symbol.for(\"nodejs.stream.destroyed\"),\n      kMaxHeadersSize: Symbol(\"max headers size\"),\n      kRunningIdx: Symbol(\"running index\"),\n      kPendingIdx: Symbol(\"pending index\"),\n      kError: Symbol(\"error\"),\n      kClients: Symbol(\"clients\"),\n      kClient: Symbol(\"client\"),\n      kParser: Symbol(\"parser\"),\n      kOnDestroyed: Symbol(\"destroy callbacks\"),\n      kPipelining: Symbol(\"pipelining\"),\n      kSocket: Symbol(\"socket\"),\n      kHostHeader: Symbol(\"host header\"),\n      kConnector: Symbol(\"connector\"),\n      kStrictContentLength: Symbol(\"strict content length\"),\n      kMaxRedirections: Symbol(\"maxRedirections\"),\n      kMaxRequests: Symbol(\"maxRequestsPerClient\"),\n      kProxy: Symbol(\"proxy agent options\"),\n      kCounter: Symbol(\"socket request counter\"),\n      kInterceptors: Symbol(\"dispatch interceptors\"),\n      kMaxResponseSize: Symbol(\"max response size\")\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/errors.js\nvar require_errors = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/errors.js\"(exports2, module2) {\n    \"use strict\";\n    init_define_process();\n    var _UndiciError = class _UndiciError extends Error {\n      constructor(message) {\n        super(message);\n        this.name = \"UndiciError\";\n        this.code = \"UND_ERR\";\n      }\n    };\n    __name(_UndiciError, \"UndiciError\");\n    var UndiciError = _UndiciError;\n    var _ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _ConnectTimeoutError);\n        this.name = \"ConnectTimeoutError\";\n        this.message = message || \"Connect Timeout Error\";\n        this.code = \"UND_ERR_CONNECT_TIMEOUT\";\n      }\n    };\n    __name(_ConnectTimeoutError, \"ConnectTimeoutError\");\n    var ConnectTimeoutError = _ConnectTimeoutError;\n    var _HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _HeadersTimeoutError);\n        this.name = \"HeadersTimeoutError\";\n        this.message = message || \"Headers Timeout Error\";\n        this.code = \"UND_ERR_HEADERS_TIMEOUT\";\n      }\n    };\n    __name(_HeadersTimeoutError, \"HeadersTimeoutError\");\n    var HeadersTimeoutError = _HeadersTimeoutError;\n    var _HeadersOverflowError = class _HeadersOverflowError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _HeadersOverflowError);\n        this.name = \"HeadersOverflowError\";\n        this.message = message || \"Headers Overflow Error\";\n        this.code = \"UND_ERR_HEADERS_OVERFLOW\";\n      }\n    };\n    __name(_HeadersOverflowError, \"HeadersOverflowError\");\n    var HeadersOverflowError = _HeadersOverflowError;\n    var _BodyTimeoutError = class _BodyTimeoutError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _BodyTimeoutError);\n        this.name = \"BodyTimeoutError\";\n        this.message = message || \"Body Timeout Error\";\n        this.code = \"UND_ERR_BODY_TIMEOUT\";\n      }\n    };\n    __name(_BodyTimeoutError, \"BodyTimeoutError\");\n    var BodyTimeoutError = _BodyTimeoutError;\n    var _ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {\n      constructor(message, statusCode, headers, body) {\n        super(message);\n        Error.captureStackTrace(this, _ResponseStatusCodeError);\n        this.name = \"ResponseStatusCodeError\";\n        this.message = message || \"Response Status Code Error\";\n        this.code = \"UND_ERR_RESPONSE_STATUS_CODE\";\n        this.body = body;\n        this.status = statusCode;\n        this.statusCode = statusCode;\n        this.headers = headers;\n      }\n    };\n    __name(_ResponseStatusCodeError, \"ResponseStatusCodeError\");\n    var ResponseStatusCodeError = _ResponseStatusCodeError;\n    var _InvalidArgumentError = class _InvalidArgumentError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _InvalidArgumentError);\n        this.name = \"InvalidArgumentError\";\n        this.message = message || \"Invalid Argument Error\";\n        this.code = \"UND_ERR_INVALID_ARG\";\n      }\n    };\n    __name(_InvalidArgumentError, \"InvalidArgumentError\");\n    var InvalidArgumentError2 = _InvalidArgumentError;\n    var _InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _InvalidReturnValueError);\n        this.name = \"InvalidReturnValueError\";\n        this.message = message || \"Invalid Return Value Error\";\n        this.code = \"UND_ERR_INVALID_RETURN_VALUE\";\n      }\n    };\n    __name(_InvalidReturnValueError, \"InvalidReturnValueError\");\n    var InvalidReturnValueError = _InvalidReturnValueError;\n    var _RequestAbortedError = class _RequestAbortedError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _RequestAbortedError);\n        this.name = \"AbortError\";\n        this.message = message || \"Request aborted\";\n        this.code = \"UND_ERR_ABORTED\";\n      }\n    };\n    __name(_RequestAbortedError, \"RequestAbortedError\");\n    var RequestAbortedError = _RequestAbortedError;\n    var _InformationalError = class _InformationalError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _InformationalError);\n        this.name = \"InformationalError\";\n        this.message = message || \"Request information\";\n        this.code = \"UND_ERR_INFO\";\n      }\n    };\n    __name(_InformationalError, \"InformationalError\");\n    var InformationalError = _InformationalError;\n    var _RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _RequestContentLengthMismatchError);\n        this.name = \"RequestContentLengthMismatchError\";\n        this.message = message || \"Request body length does not match content-length header\";\n        this.code = \"UND_ERR_REQ_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(_RequestContentLengthMismatchError, \"RequestContentLengthMismatchError\");\n    var RequestContentLengthMismatchError = _RequestContentLengthMismatchError;\n    var _ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);\n        this.name = \"ResponseContentLengthMismatchError\";\n        this.message = message || \"Response body length does not match content-length header\";\n        this.code = \"UND_ERR_RES_CONTENT_LENGTH_MISMATCH\";\n      }\n    };\n    __name(_ResponseContentLengthMismatchError, \"ResponseContentLengthMismatchError\");\n    var ResponseContentLengthMismatchError = _ResponseContentLengthMismatchError;\n    var _ClientDestroyedError = class _ClientDestroyedError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _ClientDestroyedError);\n        this.name = \"ClientDestroyedError\";\n        this.message = message || \"The client is destroyed\";\n        this.code = \"UND_ERR_DESTROYED\";\n      }\n    };\n    __name(_ClientDestroyedError, \"ClientDestroyedError\");\n    var ClientDestroyedError = _ClientDestroyedError;\n    var _ClientClosedError = class _ClientClosedError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _ClientClosedError);\n        this.name = \"ClientClosedError\";\n        this.message = message || \"The client is closed\";\n        this.code = \"UND_ERR_CLOSED\";\n      }\n    };\n    __name(_ClientClosedError, \"ClientClosedError\");\n    var ClientClosedError = _ClientClosedError;\n    var _SocketError = class _SocketError extends UndiciError {\n      constructor(message, socket) {\n        super(message);\n        Error.captureStackTrace(this, _SocketError);\n        this.name = \"SocketError\";\n        this.message = message || \"Socket error\";\n        this.code = \"UND_ERR_SOCKET\";\n        this.socket = socket;\n      }\n    };\n    __name(_SocketError, \"SocketError\");\n    var SocketError = _SocketError;\n    var _NotSupportedError = class _NotSupportedError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _NotSupportedError);\n        this.name = \"NotSupportedError\";\n        this.message = message || \"Not supported error\";\n        this.code = \"UND_ERR_NOT_SUPPORTED\";\n      }\n    };\n    __name(_NotSupportedError, \"NotSupportedError\");\n    var NotSupportedError = _NotSupportedError;\n    var _BalancedPoolMissingUpstreamError = class _BalancedPoolMissingUpstreamError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, NotSupportedError);\n        this.name = \"MissingUpstreamError\";\n        this.message = message || \"No upstream has been added to the BalancedPool\";\n        this.code = \"UND_ERR_BPL_MISSING_UPSTREAM\";\n      }\n    };\n    __name(_BalancedPoolMissingUpstreamError, \"BalancedPoolMissingUpstreamError\");\n    var BalancedPoolMissingUpstreamError = _BalancedPoolMissingUpstreamError;\n    var _HTTPParserError = class _HTTPParserError extends Error {\n      constructor(message, code, data) {\n        super(message);\n        Error.captureStackTrace(this, _HTTPParserError);\n        this.name = \"HTTPParserError\";\n        this.code = code ? `HPE_${code}` : void 0;\n        this.data = data ? data.toString() : void 0;\n      }\n    };\n    __name(_HTTPParserError, \"HTTPParserError\");\n    var HTTPParserError = _HTTPParserError;\n    var _ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {\n      constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);\n        this.name = \"ResponseExceededMaxSizeError\";\n        this.message = message || \"Response content exceeded max size\";\n        this.code = \"UND_ERR_RES_EXCEEDED_MAX_SIZE\";\n      }\n    };\n    __name(_ResponseExceededMaxSizeError, \"ResponseExceededMaxSizeError\");\n    var ResponseExceededMaxSizeError = _ResponseExceededMaxSizeError;\n    module2.exports = {\n      HTTPParserError,\n      UndiciError,\n      HeadersTimeoutError,\n      HeadersOverflowError,\n      BodyTimeoutError,\n      RequestContentLengthMismatchError,\n      ConnectTimeoutError,\n      ResponseStatusCodeError,\n      InvalidArgumentError: InvalidArgumentError2,\n      InvalidReturnValueError,\n      RequestAbortedError,\n      ClientDestroyedError,\n      ClientClosedError,\n      InformationalError,\n      SocketError,\n      NotSupportedError,\n      ResponseContentLengthMismatchError,\n      BalancedPoolMissingUpstreamError,\n      ResponseExceededMaxSizeError\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/util.js\nvar require_util = __commonJS({\n  \"../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/core/util.js\"(exports2, module2) {\n    \"use strict\";\n    init_define_process();\n    var assert = require(\"assert\");\n    var { kDestroyed, kBodyUsed } = require_symbols2();\n    var { IncomingMessage } = require(\"http\");\n    var stream = require(\"stream\");\n    var net = require(\"net\");\n    var { InvalidArgumentError: InvalidArgumentError2 } = require_errors();\n    var { Blob: Blob2 } = require(\"buffer\");\n    var nodeUtil = require(\"util\");\n    var { stringify } = require(\"querystring\");\n    var [nodeMajor, nodeMinor] = define_process_default.versions.node.split(\".\").map((v) => Number(v));\n    function nop() {\n    }\n    __name(nop, \"nop\");\n    function isStream(obj) {\n      return obj && typeof obj === \"object\" && typeof obj.pipe === \"function\" && typeof obj.on === \"function\";\n    }\n    __name(isStream, \"isStream\");\n    function isBlobLike(object) {\n      return Blob2 && object instanceof Blob2 || object && typeof object === \"object\" && (typeof object.stream === \"function\" || typeof object.arrayBuffer === \"function\") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);\n    }\n    __name(isBlobLike, \"isBlobLike\");\n    function buildURL(url, queryParams) {\n      if (url.includes(\"?\") || url.includes(\"#\")) {\n        throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".');\n      }\n      const stringified = stringify(queryParams);\n      if (stringified) {\n        url += \"?\" + stringified;\n      }\n      return url;\n    }\n    __name(buildURL, \"buildURL\");\n    function parseURL(url) {\n      if (typeof url === \"string\") {\n        url = new URL(url);\n        if (!/^https?:/.test(url.origin || url.protocol)) {\n          throw new InvalidArgumentError2(\"Invalid URL protocol: the URL must start with `http:` or `https:`.\");\n        }\n        return url;\n      }\n      if (!url || typeof url !== \"object\") {\n        throw new InvalidArgumentError2(\"Invalid URL: The URL argument must be a non-null object.\");\n      }\n      if (url.port != null && url.port !== \"\" && !Number.isFinite(parseInt(url.port))) {\n        throw new InvalidArgumentError2(\"Invalid URL: port must be a valid integer or a string representation of an integer.\");\n      }\n      if (url.path != null && typeof url.path !== \"string\") {\n        throw new InvalidArgumentError2(\"Invalid URL path: the path must be a string or null/undefined.\");\n      }\n      if (url.pathname != null && typeof url.pathname !== \"string\") {\n        throw new InvalidArgumentError2(\"Invalid URL pathname: the pathname must be a string or null/undefined.\");\n      }\n      if (url.hostname != null && typeof url.hostname !== \"string\") {\n        throw new InvalidArgumentError2(\"Invalid URL hostname: the hostname must be a string or null/undefined.\");\n      }\n      if (url.origin != null && typeof url.origin !== \"string\") {\n        throw new InvalidArgumentError2(\"Invalid URL origin: the origin must be a string or null/undefined.\");\n      }\n      if (!/^https?:/.test(url.origin || url.protocol)) {\n        throw new InvalidArgumentError2(\"Invalid UR